// Surge 脚本：VPN 节点提取器（增强版）
// 支持整体解密字段 & 分字段解密，自动识别格式，灵敏判断
// 运行类型: response
// 脚本作者: @ycheng0999 + ChatGPT 增强整合

(async () => {
  const KEYS = [
    { key: "TmPrPhkOf8by0cvx", iv: "TmPrPhkOf8by0cvx" },
    { key: "929af8c0ac9dc557", iv: "929af8c0ac9dc557" },
    { key: "817a7baa5c74b982", iv: "817a7baa5c74b982" },
    { key: "5841b418488e65cc", iv: "5841b418488e65cc" },
    { key: "AE0plfOrl4CCUO87", iv: "AE0plfOrl4CCUO87" },
    { key: "VNfo9MuDNeP8ZjYm", iv: "VNfo9MuDNeP8ZjYm" }
  ];

  const PATHS = [
    ["result", "url"],
    ["result", "web_url"],
    ["bio_result_tron", 0, "bio_link_url_tron"],
    ["prd_result_flg", "prd_kf_link_flg"],
    ["data", "url"],
    ["line_info", "link"],
    ["msg"],
    ["payload", "data", "url"]
  ];

  const REQUIRED_FIELDS = ["address", "port", "path", "node_id"];

  const Env = await loadEnv();
  const $ = new Env("VPN节点提取器", { logLevel: "info" });

  let body = $response?.body || "";
  try { if (typeof body === "string") body = JSON.parse(body); } catch (e) {
    $.msg("❌ 响应 JSON 解析失败", "", e.message);
    return $.done();
  }

  try {
    const utils = await loadUtils($);
    const CryptoJS = utils.createCryptoJS();
    const vmessList = [];

    const getFieldByPath = (obj, path) => path.reduce((o, k) => (o || {})[k], obj);
    const isEncrypted = str => typeof str === "string" && /^[A-Za-z0-9+/=]{16,}$/.test(str);

    const AES_Decrypt = (data, key, iv) => {
      try {
        const k = CryptoJS.enc.Utf8.parse(key);
        const i = CryptoJS.enc.Utf8.parse(iv);
        const decrypted = CryptoJS.AES.decrypt(data, k, { iv: i, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
        return decrypted.toString(CryptoJS.enc.Utf8);
      } catch { return ""; }
    };

    for (const path of PATHS) {
      const rawVal = getFieldByPath(body, path);
      if (!rawVal || typeof rawVal !== "string" || !isEncrypted(rawVal)) continue;

      const base64Str = decodeURIComponent(rawVal);
      for (const { key, iv } of KEYS) {
        const decrypted = AES_Decrypt(base64Str, key, iv);
        if (!decrypted) continue;

        const decoded = decrypted.trim();
        if (decoded.startsWith("vmess://")) {
          vmessList.push(decoded);
          break;
        } else {
          try {
            const vmessJson = JSON.parse(decoded);
            if (vmessJson?.add || vmessJson?.address) {
              const v2 = convertToVmess(vmessJson);
              if (v2) vmessList.push(v2);
              break;
            }
          } catch {}
        }
      }
    }

    const result = body?.result;
    if (result && typeof result === "object") {
      const fields = {};
      let allDecrypted = true;
      for (const field of REQUIRED_FIELDS) {
        const raw = result[field];
        if (!raw || typeof raw !== "string" || !isEncrypted(raw)) {
          allDecrypted = false;
          break;
        }

        const base64Str = decodeURIComponent(raw);
        let success = false;
        for (const { key, iv } of KEYS) {
          const decrypted = AES_Decrypt(base64Str, key, iv);
          if (decrypted?.trim()) {
            fields[field] = decrypted.trim();
            success = true;
            break;
          }
        }
        if (!success) { allDecrypted = false; break; }
      }

      if (allDecrypted) {
        const nodeName = result?.name || "节点";
        const surgeLine = `${nodeName} = vmess, ${fields.address}, ${fields.port}, username=${fields.node_id}, ws=true, ws-path=${fields.path}, tls=true, skip-cert-verify=true, sni=${fields.address}`;
        vmessList.push(surgeLine);
      }
    }

    if (vmessList.length === 0) throw new Error("无法生成任何 vmess 配置\n字段可能未匹配或解密失败");

    for (const vmess of vmessList) $.log(vmess);
    $.msg("✅ 解密完成", `共生成 ${vmessList.length} 条配置`, vmessList[0]);
  } catch (err) {
    $.logErr("❌ 出错", err);
    $.msg("❌ 无法生成任何 vmess 配置", "", err.message);
  } finally {
    $.done();
  }

  function convertToVmess(obj) {
    const vmess = {
      v: "2",
      ps: obj.ps || "1",
      add: obj.add || obj.address,
      port: obj.port || "443",
      id: obj.id || obj.node_id,
      aid: obj.aid || "0",
      scy: "auto",
      net: "ws",
      type: "none",
      host: obj.host || obj.add,
      path: obj.path || "/",
      tls: "tls",
      sni: obj.sni || "",
      alpn: ""
    };
    return "vmess://" + $nativeObjBase64(vmess);
  }

  function $nativeObjBase64(obj) {
    return Buffer.from(JSON.stringify(obj)).toString("base64");
  }

  async function loadUtils($) {
    const cached = $.getdata("Utils_Code");
    if (cached) { eval(cached); return creatUtils(); }
    const script = await $.get("https://cdn.jsdelivr.net/gh/xzxxn777/Surge@main/Utils/Utils.js");
    $.setdata(script, "Utils_Code");
    eval(script);
    return creatUtils();
  }

  async function loadEnv() {
    const cached = $persistentStore.read("Eric_Env_Code");
    if (cached) { eval(cached); return Env; }
    const script = await getCompatible("https://raw.githubusercontent.com/ycheng0999/cc/refs/heads/Y/evn.js");
    $persistentStore.write(script, "Eric_Env_Code");
    eval(script);
    return Env;
  }

  function getCompatible(url) {
    return new Promise((resolve, reject) => {
      if (typeof $httpClient !== "undefined") {
        $httpClient.get(url, (err, resp, data) => err ? reject(err) : resolve(data));
      } else if (typeof $task !== "undefined") {
        $task.fetch({ url }).then(resp => resolve(resp.body), reject);
      } else {
        reject("不支持的运行环境");
      }
    });
  }
})();